<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Clearmatics Libsnark: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Clearmatics Libsnark
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">C++ library for zkSNARK proofs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1 align="center">libsnark</h1>
<h4 align="center">C++ library for zkSNARK proofs</h4>
<h4 align="center">(forked from <a href="https://github.com/scipr-lab/libff">https://github.com/scipr-lab/libff</a>)</h4>
<p>___libsnark___ is a C++ library for zkSNARK proofs. The library was originally developed by <a href="http://www.scipr-lab.org/" title="Succinct Computational Integrity and Privacy Research Lab">SCIPR Lab</a> and contributors (see [AUTHORS] file) and is released under the MIT License (see [LICENSE] file).</p>
<h2>Overview</h2>
<p>This library implements <b>zkSNARK</b> schemes, which are a cryptographic method for proving/verifying, in zero knowledge, the integrity of computations.</p>
<p>A computation can be expressed as an NP statement, in forms such as the following:</p>
<ul>
<li>"The C program _foo_, when executed, returns exit code 0 if given the input _bar_ and some additional input _qux_."</li>
<li>"The Boolean circuit _foo_ is satisfiable by some input _qux_."</li>
<li>"The arithmetic circuit _foo_ accepts the partial assignment _bar_, when extended into some full assignment _qux_."</li>
<li>"The set of constraints _foo_ is satisfiable by the partial assignment _bar_, when extended into some full assignment _qux_."</li>
</ul>
<p>A prover who knows the witness for the NP statement (i.e., a satisfying input/assignment) can produce a short proof attesting to the truth of the NP statement. This proof can be verified by anyone, and offers the following properties.</p>
<ul>
<li><b>Zero knowledge:</b> the verifier learns nothing from the proof beside the truth of the statement (i.e., the value <em>qux</em>, in the above examples, remains secret).</li>
<li><b>Succinctness:</b> the proof is short and easy to verify.</li>
<li><b>Non-interactivity:</b> the proof is a string (i.e. it does not require back-and-forth interaction between the prover and the verifier).</li>
<li><b>Soundness:</b> the proof is computationally sound (i.e., it is infeasible to fake a proof of a false NP statement). Such a proof system is also called an <em>argument</em>.</li>
<li><b>Proof of knowledge:</b> the proof attests not just that the NP statement is true, but also that the prover knows why (e.g., knows a valid <em>qux</em>).</li>
</ul>
<p>These properties are summarized by the <em>zkSNARK</em> acronym, which stands for <em>Zero-Knowledge Succinct Non-interactive ARgument of Knowledge</em> (though zkSNARKs are also knows as <em>succinct non-interactive computationally-sound zero-knowledge proofs of knowledge</em>). For formal definitions and theoretical discussions about these, see [BCCT12], [BCIOP13], and the references therein.</p>
<p>The libsnark library currently provides a C++ implementation of:</p>
<ol type="1">
<li>General-purpose proof systems:<ol type="a">
<li><p class="startli">A preprocessing zkSNARK for the NP-complete language "R1CS" (<em>Rank-1 Constraint Systems</em>), which is a language that is similar to arithmetic circuit satisfiability.</p>
<p class="startli">This zkSNARK construction follows, extends, and optimizes the approach described in [BCTV14a], itself an extension of [BCGTV13], following the approach of [GGPR13] and [BCIOP13]. (An alternative implementation of this approach is the <em>Pinocchio</em> system of [PGHR13].)</p>
</li>
<li>A preprocessing SNARK for a language of arithmetic circuits, "BACS" (<em>Bilinear Arithmetic Circuit Satisfiability</em>). This simplifies the writing of NP statements when the additional flexibility of R1CS is not needed. Internally, it reduces to R1CS.</li>
<li>A preprocessing SNARK for the language "USCS" (<em>Unitary-Square Constraint Systems</em>). This abstracts and implements the core contribution of [DFGK14]</li>
<li>A preprocessing SNARK for a language of Boolean circuits, "TBCS" (<em>Two-input Boolean Circuit Satisfiability</em>). Internally, it reduces to USCS. This is much more efficient than going through R1CS.</li>
<li>A simulation-extractable preprocessing SNARK for R1CS. This construction uses the approach described in [GM17]. For arithmetic circuits, it is slower than the [BCTV14a] approach, but produces shorter proofs.</li>
<li>ADSNARK, a preprocessing SNARKs for proving statements on authenticated data, as described in [BBFR15].</li>
<li>Proof-Carrying Data (PCD). This uses recursive composition of SNARKs, as explained in [BCCT13] and optimized in [BCTV14b].</li>
</ol>
</li>
<li>Gadget libraries (gadgetlib1 and <a class="el" href="namespacegadgetlib2.html">gadgetlib2</a>) for constructing R1CS instances out of modular "gadget" classes.</li>
<li>Examples of applications that use the above proof systems to prove statements about:<ol type="a">
<li>Several toy examples.</li>
<li>Execution of TinyRAM machine code, as explained in [BCTV14a] and [BCGTV13]. (Such machine code can be obtained, e.g., by compiling from C.) This is easily adapted to any other Random Access Machine that satisfies a simple load-store interface.</li>
<li>A scalable for TinyRAM using Proof-Carrying Data, as explained in [BCTV14b]</li>
<li>Zero-knowldge cluster MapReduce, as explained in [CTV15].</li>
</ol>
</li>
</ol>
<p>See the above references for discussions of efficiency aspects that arise in practical use of such constructions, as well as security and trust considerations.</p>
<p>This scheme is a <em>preprocessing zkSNARK</em> (<em>ppzkSNARK</em>): before proofs can be created and verified, one needs to first decide on a size/circuit/system representing the NP statements to be proved, and run a <em>generator</em> algorithm to create corresponding public parameters (a long proving key and a short verification key).</p>
<p>Using the library involves the following high-level steps:</p>
<ol type="1">
<li>Express the statements to be proved as an R1CS (or any of the other languages above, such as arithmetic circuits, Boolean circuits, or TinyRAM). This is done by writing C++ code that constructs an R1CS, and linking this code together with libsnark</li>
<li>Use libsnark's generator algorithm to create the public parameters for this statement (once and for all).</li>
<li>Use libsnark's prover algorithm to create proofs of true statements about the satisfiability of the R1CS.</li>
<li>Use libsnark's verifier algorithm to check proofs for alleged statements.</li>
</ol>
<h2>The NP-complete language R1CS</h2>
<p>The ppzkSNARK supports proving/verifying membership in a specific NP-complete language: R1CS (<em>rank-1 constraint systems</em>). An instance of the language is specified by a set of equations over a prime field F, and each equation looks like: &lt; A, (1,X) &gt; * &lt; B , (1,X) &gt; = &lt; C, (1,X) &gt; where A,B,C are vectors over F, and X is a vector of variables.</p>
<p>In particular, arithmetic (as well as boolean) circuits are easily reducible to this language by converting each gate into a rank-1 constraint. See [BCGTV13] Appendix E (and "System of Rank 1 Quadratic Equations") for more details about this.</p>
<h2>Elliptic curve choices</h2>
<p>The ppzkSNARK can be instantiated with different parameter choices, depending on which elliptic curve is used (see curves supported in <a href="https://github.com/clearmatics/libff">libff</a>)</p>
<h2>Gadget libraries</h2>
<p>The libsnark library currently provides two libraries for conveniently constructing R1CS instances out of reusable "gadgets". Both libraries provide a way to construct gadgets on other gadgets as well as additional explicit equations. In this way, complex R1CS instances can be built bottom up.</p>
<h3>gadgetlib1</h3>
<p>This is a low-level library which expose all features of the preprocessing zkSNARK for R1CS. Its design is based on templates (as does the ppzkSNARK code) to efficiently support working on multiple elliptic curves simultaneously. This library is used for most of the constraint-building in libsnark, both internal (reductions and Proof-Carrying Data) and examples applications.</p>
<h3><a class="el" href="namespacegadgetlib2.html">gadgetlib2</a></h3>
<p>This is an alternative library for constructing systems of polynomial equations and, in particular, also R1CS instances. It is better documented and easier to use than gadgetlib1, and its interface does not use templates. However, fewer useful gadgets are provided.</p>
<h2>Security</h2>
<p>The theoretical security of the underlying mathematical constructions, and the requisite assumptions, are analyzed in detailed in the aforementioned research papers.</p>
<p><b>This code is a research-quality proof of concept, and has not yet undergone extensive review or testing. It is thus not suitable, as is, for use in critical or production systems.</b></p>
<p>Known issues include the following:</p>
<ul>
<li>The ppzkSNARK's generator and prover exhibit data-dependent running times and memory usage. These form timing and cache-contention side channels, which may be an issue in some applications.</li>
<li>Randomness is retrieved from /dev/urandom, but this should be changed to a carefully considered (depending on system and threat model) external, high-quality randomness source when creating long-term proving/verification keys.</li>
</ul>
<h2>Build instructions</h2>
<h3>Dependencies</h3>
<p>The libsnark library relies on the following:</p>
<ul>
<li>C++ build environment</li>
<li>CMake build infrastructure</li>
<li>GMP for certain bit-integer arithmetic</li>
<li>libprocps for reporting memory usage</li>
<li>Fetched and compiled via Git submodules:<ul>
<li><a href="https://github.com/clearmatics/libff">libff</a> for finite fields and elliptic curves</li>
<li><a href="https://github.com/clearmatics/libfqfft">libfqfft</a> for fast polynomial evaluation and interpolation in various finite domains</li>
<li><a href="https://github.com/herumi/ate-pairing">ate-pairing</a> for the BN128 elliptic curve</li>
<li><a href="https://github.com/herumi/xbyak">xbyak</a> just-in-time assembler, for the BN128 elliptic curve</li>
<li><a href="https://github.com/mbbarbosa/libsnark-supercop">Subset of SUPERCOP</a> for crypto primitives needed by ADSNARK</li>
</ul>
</li>
</ul>
<p>Furthermore, Doxygen is used to generate the documentation.</p>
<p>So far we have tested these only on Linux, though we have been able to make the libsnark work, with some features disabled (such as memory profiling or GTest tests), on Windows via Cygwin and on Mac OS X. See also the notes on <a href="#portability">portability</a> below. (If you port libsnark to additional platforms, please let us know!)</p>
<p>Concretely, here are the requisite packages in some Linux distributions:</p>
<ul>
<li>On Ubuntu 20.04 LTS:</li>
</ul>
<div class="fragment"><div class="line">sudo apt install \</div>
<div class="line">    build-essential \</div>
<div class="line">    git \</div>
<div class="line">    libboost-all-dev \</div>
<div class="line">    cmake \</div>
<div class="line">    libgmp3-dev \</div>
<div class="line">    libssl-dev \</div>
<div class="line">    libprocps-dev \</div>
<div class="line">    pkg-config</div>
</div><!-- fragment --><ul>
<li>On Ubuntu 16.04 LTS:</li>
</ul>
<div class="fragment"><div class="line">sudo apt-get install \</div>
<div class="line">    build-essential \</div>
<div class="line">    cmake \</div>
<div class="line">    git \</div>
<div class="line">    libgmp3-dev \</div>
<div class="line">    libprocps4-dev \</div>
<div class="line">    libboost-all-dev \</div>
<div class="line">    libssl-dev</div>
</div><!-- fragment --><ul>
<li>On Ubuntu 14.04 LTS:</li>
</ul>
<div class="fragment"><div class="line">sudo apt-get install \</div>
<div class="line">    build-essential \</div>
<div class="line">    cmake \</div>
<div class="line">    git \</div>
<div class="line">    libgmp3-dev \</div>
<div class="line">    libprocps3-dev \</div>
<div class="line">    libboost-all-dev \</div>
<div class="line">    libssl-dev</div>
</div><!-- fragment --><ul>
<li>On Fedora 20 through 23:</li>
</ul>
<div class="fragment"><div class="line">sudo yum install \</div>
<div class="line">    gcc-c++ \</div>
<div class="line">    cmake \</div>
<div class="line">    make \</div>
<div class="line">    git \</div>
<div class="line">    gmp-devel \</div>
<div class="line">    procps-ng-devel</div>
</div><!-- fragment --><h3>Building</h3>
<p>Fetch dependencies from their GitHub repos:</p>
<div class="fragment"><div class="line">git submodule update --init --recursive</div>
</div><!-- fragment --><p>Create the Makefile:</p>
<div class="fragment"><div class="line">mkdir build &amp;&amp; cd build &amp;&amp; cmake ..</div>
</div><!-- fragment --><p>Then, to compile the library, tests, and profiling harness, run this within the <code>build</code> directory:</p>
<div class="fragment"><div class="line">make</div>
</div><!-- fragment --><p>To create the <a href="https://www.doxygen.nl/index.html">Doxygen</a> documentation, run:</p>
<div class="fragment"><div class="line"># Make sure to install doxygen if not already</div>
<div class="line"># e.g. on Ubuntu run: apt-get install doxygen graphviz</div>
<div class="line">cd build &amp;&amp; cmake .. -DGEN_DOC=ON &amp;&amp; make docs</div>
</div><!-- fragment --><p>To compile and run the tests for this library, run:</p>
<div class="fragment"><div class="line">make check</div>
</div><!-- fragment --><h3>Using libsnark as a library</h3>
<p>To develop an application that uses libsnark, it's recommended to use your own build system that incorporates libsnark and dependencies. If you're using CMake, add libsnark as a git submodule, and then add it as a subdirectory. Then, add <code>snark</code> as a library dependency to the appropriate rules.</p>
<p>To build <em>and install</em> the libsnark library:</p>
<div class="fragment"><div class="line">DESTDIR=/install/path make install</div>
</div><!-- fragment --><p>This will install <code>libsnark.a</code> into <code>/install/path/lib</code>; so your application should be linked using <code>-L/install/path/lib -lsnark</code>. It also installs the requisite headers into <code>/install/path/include</code>; so your application should be compiled using <code>-I/install/path/include</code>.</p>
<p>In addition, unless you use <code>WITH_SUPERCOP=OFF</code>, <code>libsnark_adsnark.a</code> will be installed and should be linked in using <code>-lsnark_adsnark</code>.</p>
<p>When you use compile your application against <code>libsnark</code>, you must have the same conditional defines (<code>#define FOO</code> or <code>g++ -DFOO</code>) as when you compiled <code>libsnark</code>, due to the use of templates. One way to figure out the correct conditional defines is to look at <code>build/libsnark/CMakeFiles/snark.dir/flags.make</code> after running <code>cmake</code>. (<a href="https://github.com/scipr-lab/libsnark/issues/21">Issue #21</a>)</p>
<h3>Building on Windows using Cygwin</h3>
<p>Install Cygwin using the graphical installer, including the <code>g++</code>, <code>libgmp</code>, <code>cmake</code>, and <code>git</code> packages. Then disable the dependencies not easily supported under CygWin, using:</p>
<div class="fragment"><div class="line">cmake -DWITH_PROCPS=OFF ..</div>
</div><!-- fragment --><h3>Building on Mac OS X</h3>
<p>On Mac OS X, install GMP from MacPorts (<code>port install gmp</code>). Then disable the dependencies not easily supported under OS X, using:</p>
<div class="fragment"><div class="line">cmake -DWITH_PROCPS=OFF ..</div>
</div><!-- fragment --><p>MacPorts does not write its libraries into standard system folders, so you might need to explicitly provide the paths to the header files and libraries by appending <code>CXXFLAGS=-I/opt/local/include LDFLAGS=-L/opt/local/lib</code> to the line above.</p>
<h2>Build options</h2>
<p>Check <a href="./CMakeLists.txt">CMakelists.txt</a> for the whole list of build options. Some details are provided below.</p>
<ul>
<li><code>cmake -DCURVE=choice</code> (where <code>choice</code> is one of: ALT_BN128, BN128, EDWARDS, MNT4, MNT6): Set the default curve to one of the above (see <a href="#elliptic-curve-choices">elliptic curve choices</a>).</li>
<li><code>cmake -DLOWMEM=ON</code>: Limit the size of multi-exponentiation tables, for low-memory platforms.</li>
<li><code>cmake -DWITH_PROCPS=OFF</code>: Do not link against libprocps. This disables memory profiling.</li>
<li><code>cmake -DWITH_SUPERCOP=OFF</code>: Do not link against SUPERCOP for optimized crypto. The ADSNARK executables will not be built.</li>
<li><code>cmake -DMULTICORE=ON</code>: Enable parallelized execution of the ppzkSNARK generator and prover, using OpenMP. This will utilize all cores on the CPU for heavyweight parallelizable operations such as FFT and multiexponentiation. The default is single-core. To override the maximum number of cores used, set the environment variable <code>OMP_NUM_THREADS</code> at runtime (not compile time), e.g., <code>OMP_NUM_THREADS=8 test_r1cs_sp_ppzkpc</code>. It defaults to the autodetected number of cores, but on some devices, dynamic core management confused OpenMP's autodetection, so setting <code>OMP_NUM_THREADS</code> is necessary for full utilization.</li>
<li><code>cmake -DUSE_PT_COMPRESSION=OFF</code>: Do not use point compression. This gives much faster serialization times, at the expense of ~2x larger sizes for serialized keys and proofs.</li>
<li><code>cmake -DMONTGOMERY_OUTPUT=ON</code>: Serialize Fp elements as their Montgomery representations. If this option is disabled then Fp elements are serialized as their equivalence classes, which is slower but produces human-readable output.</li>
<li><code>cmake -DBINARY_OUTPUT=ON</code>: In serialization, output raw binary data (instead of decimal), which is smaller and faster.</li>
<li><code>cmake -DPROFILE_OP_COUNTS=ON</code>: Collect counts for field and curve operations inside static variables of the corresponding algebraic objects. This option works for all curves except bn128.</li>
<li><code>cmake -DUSE_ASM=ON</code>: Use architecture-specific assembly routines for F[p] arithmetic and heap in multi-exponentiation. (If disabled, use GMP's <code>mpn_*</code> routines instead.)</li>
<li><code>cmake -DPERFORMANCE=ON</code>: Enables compiler optimizations such as link-time optimization, and disables debugging aids. (On some distributions this causes a <code>plugin needed to handle lto object</code> link error and <code>undefined reference</code>s, which can be remedied by <code>AR=gcc-ar make ...</code>.)</li>
<li><code>cmake -DOPT_FLAGS=...</code>: Set the C++ compiler optimization flags, overriding the default (e.g., <code>-DOPT_FLAGS="-Os -march=i386"</code>).</li>
<li><code>cmake -DDEPENDS_DIR=...</code>: Sets the dependency installation directory to the provided absolute path (default: installs dependencies in the respective submodule directories)</li>
<li><code>cmake -DUSE_LINKED_LIBRARIES=ON</code>: Setting this flag enables CMake to include installed <code>libfqfft</code> and <code>libff</code> libraries. This will tell the compiler to ignore the <code>libfqfft</code> and <code>libff</code> dependencies provided in the <code>depends</code> folder.</li>
</ul>
<p><b>Note:</b> Not all combinations are tested together or supported by every part of the codebase.</p>
<h2>Tutorials</h2>
<p>libsnark includes a tutorial, and some usage examples, for the high-level API.</p>
<ul>
<li><code>libsnark/gadgetlib1/examples1</code> contains a simple example for constructing a constraint system using gadgetlib1.</li>
<li><code>libsnark/gadgetlib2/examples</code> contains a tutorial for using <a class="el" href="namespacegadgetlib2.html">gadgetlib2</a> to express NP statements as constraint systems. It introduces basic terminology, design overview, and recommended programming style. It also shows how to invoke ppzkSNARKs on such constraint systems. The main file, <code><a class="el" href="tutorial_8cpp.html">tutorial.cpp</a></code>, builds into a standalone executable.</li>
<li><code><a class="el" href="profile__r1cs__ppzksnark_8cpp.html">libsnark/zk_proof_systems/ppzksnark/r1cs_ppzksnark/profiling/profile_r1cs_ppzksnark.cpp</a></code> constructs a simple constraint system and runs the ppzksnark. See below for how to run it.</li>
</ul>
<h2>Executing profiling example</h2>
<p>The command</p>
<div class="fragment"><div class="line">libsnark/zk_proof_systems/ppzksnark/r1cs_ppzksnark/profiling/profile_r1cs_ppzksnark 1000 10 Fr</div>
</div><!-- fragment --><p>exercises the ppzkSNARK (first generator, then prover, then verifier) on an R1CS instance with 1000 equations and an input consisting of 10 field elements.</p>
<p>(If you get the error <code>zmInit ERR:can't protect</code>, see the discussion <a href="#elliptic-curve-choices">above</a>.)</p>
<p>The command</p>
<div class="fragment"><div class="line">libsnark/zk_proof_systems/ppzksnark/r1cs_ppzksnark/profiling/profile_r1cs_ppzksnark 1000 10 bytes</div>
</div><!-- fragment --><p>does the same but now the input consists of 10 bytes.</p>
<h2>Portability</h2>
<p>libsnark is written in fairly standard C++11.</p>
<p>However, having been developed on Linux on x86-64 CPUs, libsnark has some limitations with respect to portability. Specifically:</p>
<ol type="1">
<li>libsnark's algebraic data structures assume little-endian byte order.</li>
<li>Profiling routines use <code>clock_gettime</code> and <code>readproc</code> calls, which are Linux-specific.</li>
<li>Random-number generation is done by reading from <code>/dev/urandom</code>, which is specific to Unix-like systems.</li>
<li>libsnark binary serialization routines (see <code>BINARY_OUTPUT</code> above) assume a fixed machine word size (i.e. sizeof(mp_limb_t) for GMP's limb data type). Objects serialized in binary on a 64-bit system cannot be de-serialized on a 32-bit system, and vice versa. (The decimal serialization routines have no such limitation.)</li>
<li>libsnark requires a C++ compiler with good C++11 support. It has been tested with g++ 4.7 and newer, and clang 3.4 and newer.</li>
<li>On x86-64, we by default use highly optimized assembly implementations for some operations (see <code>USE_ASM</code> above). On other architectures we fall back to a portable C++ implementation, which is slower.</li>
<li>The ate-pairing library, require by the BN128 curve, can be compiled only on i686 and x86-64. (On other platforms, use other <code>-DCURVE=...</code> choices.)</li>
<li>The SUPERCOP library, required by ADSNARK, can be compiled only on i686 and x86-64. (On other platforms, use <code>-DWITH_SUPERCOP=OFF</code>.)</li>
</ol>
<p>Tested configurations include:</p>
<ul>
<li>Debian jessie with g++ 4.7 on x86-64</li>
<li>Debian jessie with clang 3.4 on x86-64</li>
<li>Fedora 20/21 with g++ 4.8.2/4.9.2 on x86-64</li>
<li>Fedora 21 with g++ 4.9.2 on x86-32, for non-BN128 curves (<code>-DWITH_SUPERCOP=OFF</code>)</li>
<li>Ubuntu 14.04 LTS with g++ 4.8 on x86-64</li>
<li>Ubuntu 14.04 LTS with g++ 4.8 on x86-32, for non-BN128 curves (<code>-DWITH_SUPERCOP=OFF</code>)</li>
<li>Ubuntu 15.04/16.04 LTS with g++ 4.9.2/5.3.1 on ARM AArch32/AArch64, for non-BN128 curve choices</li>
<li>Debian wheezy with g++ 4.7 on ARM little endian (Debian armel port) inside QEMU, for EDWARDS and ALT_BN128 curve choices</li>
<li>Windows 7 with g++ 4.8.3 under Cygwin 1.7.30 on x86-64 for EDWARDS and ALT_BN128 curve choices (<code>-DWITH_PROCPS=OFF</code> and GTestdisabled)</li>
<li>Mac OS X 10.9.4 (Mavericks) with Apple LLVM version 5.1 (based on LLVM 3.4svn) on x86-64 (<code>-DWITH_PROCPS=OFF</code> and GTest disabled)</li>
</ul>
<h2>Directory structure</h2>
<p>The directory structure of the libsnark library is as follows:</p>
<ul>
<li>[<b>libsnark</b>](libsnark): main C++ source code, containing the following modules:<ul>
<li><a href="libsnark/common"><b>common</b></a>: miscellaneous utilities</li>
<li><a href="libsnark/gadgetlib1"><b>gadgetlib1</b></a>: gadgetlib1, a library to construct R1CS instances<ul>
<li><a href="libsnark/gadgetlib1/gadgets"><b>gadgets</b></a>: basic gadgets for gadgetlib1</li>
</ul>
</li>
<li><a href="libsnark/gadgetlib2"><b>gadgetlib2</b></a>: <a class="el" href="namespacegadgetlib2.html">gadgetlib2</a>, a library to construct R1CS instances</li>
<li><a href="libsnark/relations"><b>relations</b></a>: interfaces for expressing statement (relations between instances and witnesses) as various NP-complete languages<ul>
<li><a href="libsnark/relations/constraint_satisfaction_problems"><b>constraint_satisfaction_problems</b></a>: R1CS and USCS languages</li>
<li><a href="libsnark/relations/circuit_satisfaction_problems"><b>circuit_satisfaction_problems</b></a>: Boolean and arithmetic circuit satisfiability languages</li>
<li><a href="libsnark/relations/ram_computations"><b>ram_computations</b></a>: RAM computation languages</li>
</ul>
</li>
<li><a href="libsnark/zk_proof_systems"><b>zk_proof_systems</b></a>: interfaces and implementations of the proof systems</li>
<li><a href="libsnark/reductions"><b>reductions</b></a>: reductions between languages (used internally, but contains many examples of building constraints)</li>
</ul>
</li>
<li>[<b>depends</b>](depends): external dependencies which are automatically fetched and compiled (overridable by <code>cmake -DDEPENDS_DIR=...</code>)</li>
</ul>
<p>Some of these module directories have the following subdirectories:</p>
<ul>
<li>...<ul>
<li><b>examples</b>: example code and tutorials for this module</li>
<li><b>tests</b>: unit tests for this module</li>
</ul>
</li>
</ul>
<p>In particular, the top-level API examples are at <code>libsnark/r1cs_ppzksnark/examples/</code> and <code>libsnark/gadgetlib2/examples/</code>.</p>
<h2>Further considerations</h2>
<h3>Multiexponentiation window size</h3>
<p>The ppzkSNARK's generator has to solve a fixed-base multi-exponentiation problem. We use a window-based method in which the optimal window size depends on the size of the multiexponentiation instance <em>and</em> the platform.</p>
<p>On our benchmarking platform (a 3.40 GHz Intel Core i7-4770 CPU), we have computed for each curve optimal windows, provided as <code>fixed_base_exp_window_table</code> initialization sequences, for each curve; see <code>X_init.cpp</code> for X=edwards,bn128,alt_bn128.</p>
<p>Performance on other platforms may not be optimal (but probably not be far off). Future releases of the libsnark library will include a tool that generates optimal window sizes.</p>
<h2>References</h2>
<p>[BBFR15] [ <em>ADSNARK: nearly practical and privacy-preserving proofs on authenticated data</em> ](<a href="https://eprint.iacr.org/2014/617">https://eprint.iacr.org/2014/617</a>), Michael Backes, Manuel Barbosa, Dario Fiore, Raphael M. Reischuk, IEEE Symposium on Security and Privacy (Oakland) 2015</p>
<p>[BCCT12] [ <em>From extractable collision resistance to succinct non-Interactive arguments of knowledge, and back again</em> ](<a href="http://eprint.iacr.org/2011/443">http://eprint.iacr.org/2011/443</a>), Nir Bitansky, Ran Canetti, Alessandro Chiesa, Eran Tromer, Innovations in Computer Science (ITCS) 2012</p>
<p>[BCCT13] [ <em>Recursive composition and bootstrapping for SNARKs and proof-carrying data</em> ](<a href="http://eprint.iacr.org/2012/095">http://eprint.iacr.org/2012/095</a>) Nir Bitansky, Ran Canetti, Alessandro Chiesa, Eran Tromer, Symposium on Theory of Computing (STOC) 13</p>
<p>[BCGTV13] [ <em>SNARKs for C: Verifying Program Executions Succinctly and in Zero Knowledge</em> ](<a href="http://eprint.iacr.org/2013/507">http://eprint.iacr.org/2013/507</a>), Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, Madars Virza, CRYPTO 2013</p>
<p>[BCIOP13] [ <em>Succinct non-interactive arguments via linear interactive Proofs</em> ](<a href="http://eprint.iacr.org/2012/718">http://eprint.iacr.org/2012/718</a>), Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, Omer Paneth, Theory of Cryptography Conference 2013</p>
<p>[BCTV14a] [ <em>Succinct non-interactive zero knowledge for a von Neumann architecture</em> ](<a href="http://eprint.iacr.org/2013/879">http://eprint.iacr.org/2013/879</a>), Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, Madars Virza, USENIX Security 2014</p>
<p>[BCTV14b] [ <em>Scalable succinct non-interactive arguments via cycles of elliptic curves</em> ](<a href="https://eprint.iacr.org/2014/595">https://eprint.iacr.org/2014/595</a>), Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, Madars Virza, CRYPTO 2014</p>
<p>[CTV15] [ <em>Cluster computing in zero knowledge</em> ](<a href="https://eprint.iacr.org/2015/377">https://eprint.iacr.org/2015/377</a>), Alessandro Chiesa, Eran Tromer, Madars Virza, Eurocrypt 2015</p>
<p>[DFGK14] [ Square span programs with applications to succinct NIZK arguments ](<a href="https://eprint.iacr.org/2014/718">https://eprint.iacr.org/2014/718</a>), George Danezis, Cedric Fournet, Jens Groth, Markulf Kohlweiss, ASIACCS 2014</p>
<p>[GM17] [ Snarky Signatures: Minimal Signatures of Knowledge from Simulation-Extractable SNARKs ](<a href="https://eprint.iacr.org/2017/540">https://eprint.iacr.org/2017/540</a>), Jens Groth and Mary Maller, IACR-CRYPTO-2017</p>
<p>[GGPR13] [ <em>Quadratic span programs and succinct NIZKs without PCPs</em> ](<a href="http://eprint.iacr.org/2012/215">http://eprint.iacr.org/2012/215</a>), Rosario Gennaro, Craig Gentry, Bryan Parno, Mariana Raykova, EUROCRYPT 2013</p>
<p>[ate-pairing] [ <em>High-Speed Software Implementation of the Optimal Ate Pairing over Barreto-Naehrig Curves</em> ](<a href="https://github.com/herumi/ate-pairing">https://github.com/herumi/ate-pairing</a>), MITSUNARI Shigeo, TERUYA Tadanori</p>
<p>[PGHR13] [ <em>Pinocchio: Nearly Practical Verifiable Computation</em> ](<a href="http://eprint.iacr.org/2013/279">http://eprint.iacr.org/2013/279</a>), Bryan Parno, Craig Gentry, Jon Howell, Mariana Raykova, IEEE Symposium on Security and Privacy (Oakland) 2013 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 25 2023 11:05:58 for Clearmatics Libsnark by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
