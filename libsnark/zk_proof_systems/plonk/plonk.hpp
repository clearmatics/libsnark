/** @file
*****************************************************************************

Declaration of interfaces for ppzkSNARK proof system Plonk.

This includes:
- class srs
- class for proving key
- class for verification key
- class for key pair (proving key & verification key)
- class for proof
- generator algorithm / setup
- prover algorithm
- verifier algorithm 

The implementation instantiates the protocol of PlonK \[GWC19],

References:

\[GWC19]: 
"Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge",
Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru,
Cryptology ePrint Archive, Report 2019/953, 2019,
<https://eprint.iacr.org/2019/953>

*****************************************************************************
* @author     This file is part of libsnark, developed by SCIPR Lab
*             and contributors (see AUTHORS).
* @copyright  MIT license (see LICENSE file)
*****************************************************************************/

#ifndef PLONK_PPZKSNARK_HPP_
#define PLONK_PPZKSNARK_HPP_

#include <libff/algebra/curves/public_params.hpp>
#include <memory>

#define DEBUG 1

// number of generators for H, Hk1, Hk2
const size_t NUM_HGEN = 3;

namespace libsnark
{

  enum W_polys_id{a, b, c};
  enum Q_polys_id{L, R, M, O, C};
  enum t_polys_id{lo, mid, hi};
  enum omega_id{base, base_k1, base_k2};

template<typename FieldT> using polynomial = std::vector<FieldT>;

/************************ Common Preprocessed Input ***********************/
template<typename ppT> class common_preprocessed_input
{
public:
  using Field = libff::Fr<ppT>;
  // number of gates / constraints
  size_t num_gates;
  // number of selector polynomials (q-polynomials) (= 5 in the
  // vanilla Plonk proposal [GWC19])
  size_t num_qpolys;
  // Lagrange basis
  std::vector<polynomial<Field>> L_basis;
  // Public input polynomial
  polynomial<Field> PI_poly;
  // Circuit selector polynomials (Q-polynomials)
  std::vector<polynomial<Field>> Q_polys;
  // Permutation polynomials S_sigma_1, S_sigma_2, S_sigma_2 (see
  // [GWC19], Sect. 8.1)
  std::vector<polynomial<Field>> S_polys;
  // omega[0] are the n roots of unity, omega[1] are omega[0]*k1,
  // omega[2] are omega[0]*k2
  std::vector<std::vector<Field>> omega_roots;
  // H_gen contains the generators of H, k1 H and k2 H in one place
  // ie. omega, omega_k1 and omega_k2
  std::vector<Field> H_gen;
  // H_gen permuted according to the wire permutation
  std::vector<Field> H_gen_permute;

  common_preprocessed_input(){};
  
};  

/********************************** SRS ***********************************/

/// The srs generated by the setup step. See kzg10.hpp .
template<typename ppT> class srs
{
public:
  srs(std::vector<libff::G1<ppT>> &&secret_powers_g1,
      std::vector<libff::G2<ppT>> &&secret_powers_g2);

  /// Array of powers of secret \alpha, encoded in G1:
  /// [1]_1, [\alpha]_1, [\alpha^2]_1, ..., [\alpha^{n+2}]_1
  std::vector<libff::G1<ppT>> secret_powers_g1;
  
  /// Array of powers of secret \alpha, encoded in G2:
  /// [1]_2, [\alpha]_2
  std::vector<libff::G2<ppT>> secret_powers_g2;

};

  
  
/******************************** Proving key ********************************/
/**
 * A proving key for Plonk
 */
template<typename ppT> class plonk_proving_key
{
public:
  /// Array of powers of secret \alpha, encoded in G1:
  /// [1]_1, [\alpha]_1, [\alpha^2]_1, ..., [\alpha^{n+2}]_1
  std::vector<libff::G1<ppT>> secret_powers_g1;

  plonk_proving_key(){};
  plonk_proving_key(
		    std::vector<libff::G1<ppT>>&& secret_powers_g1)
    :secret_powers_g1(std::move(secret_powers_g1)){};
};

/******************************* Verification key ****************************/

/**
 * A verification key for Plonk
 */
template<typename ppT> class plonk_verification_key
{
public:
  /// Array of powers of secret \alpha, encoded in G2:
  /// [1]_2, [\alpha]_2
  std::vector<libff::G2<ppT>> secret_powers_g2;
  
  plonk_verification_key();
  plonk_verification_key(
		    std::vector<libff::G2<ppT>>&& secret_powers_g2)
    :secret_powers_g2(std::move(secret_powers_g2)){};
};

/********************************** Key pair *********************************/

/**
 * A key pair for Plonk, which consists of a proving key and a
 * verification key.
 */
template<typename ppT> class plonk_keypair
{
public:
    plonk_proving_key<ppT> pk;
    plonk_verification_key<ppT> vk;

    plonk_keypair() = default;
    plonk_keypair(const plonk_keypair<ppT> &other) =
        default;
    plonk_keypair(
        plonk_proving_key<ppT> &&pk,
        plonk_verification_key<ppT> &&vk)
        : pk(std::move(pk)), vk(std::move(vk))
    {
    }

    plonk_keypair(plonk_keypair<ppT> &&other) = default;
};
  
/*********************************** Proof ***********************************/

/**
 * A proof for the Plonk GG-ppzkSNARK.
 */
template<typename ppT> class plonk_proof
{
public:
  // proof elements

  plonk_proof() {};
};
  
/***************************** Main algorithms *******************************/

//  template<typename FieldT> void print_vector(std::vector<FieldT> v);

  
  // Generate SRS \see r1cs_gg_ppzksnark_generator_from_secrets, \see
  // kzg10<ppT>::setup_from_secret(
  template<typename ppT>
  srs<ppT> plonk_setup_from_secret(
				   const libff::Fr<ppT> secret,
				   size_t num_gates
				   );

  
} // namespace libsnark

#include "libsnark/zk_proof_systems/plonk/plonk.tcc"

#endif // PLONK_PPZKSNARK_HPP_
