/** @file
 *****************************************************************************
 * @author     This file is part of libff, developed by Clearmatics Ltd
 *             (originally developed by SCIPR Lab) and contributors
 *             (see AUTHORS).
 * @copyright  MIT license (see LICENSE file)
 *****************************************************************************/

#ifndef __LIBSNARK_POLYNOMIAL_COMMITMENTS_KZG10_BATCHED_HPP__
#define __LIBSNARK_POLYNOMIAL_COMMITMENTS_KZG10_BATCHED_HPP__

#include "libsnark/polynomial_commitments/kzg10.hpp"

/// Reference:
/// - [GWC19]:
///   Title: "PLONK: Permutations over Lagrange-bases for Oecumenical
///           Noninteractive arguments of Knowledge"
///   eprint: https://eprint.iacr.org/2019/953.pdf

namespace libsnark
{

/// Batched version of KZG10, as described in Section 3 of [GWC19]. Supports
/// evaluation of arbitrary number of polynomials at 2 points, requiring a
/// fixed-size witness (of 2 elements of G1), which can be verified with 2
/// pairings (similarly to KZG10) and a number of group operations proportional
/// to the number of polynomials.
///
/// Note, this could be extended to the case of N evaluation points (and
/// thereby N sets of polynomials).
template<typename ppT> class kzg10_batched_2_point
{
public:
    using Field = libff::Fr<ppT>;

    /// The srs generated by the setup step. This is denoted PK in [KZG10]
    /// section 3.2.
    using srs = typename kzg10<ppT>::srs;

    using commitment = typename kzg10<ppT>::commitment;

    using witness = typename kzg10<ppT>::witness;

    /// The values chosen by the verifier in the interactive
    /// protocol. Namely, the points at which to evaluate each set of
    /// polynomials, and the randomness to use in witness generation.
    class multi_point_evaluation_challenge
    {
    public:
        const Field z_1;
        const Field z_2;
        const Field gamma_1;
        const Field gamma_2;

        multi_point_evaluation_challenge(
            const Field &z_1,
            const Field &z_2,
            const Field &gamma_1,
            const Field &gamma_2);
    };

    /// The evaluation witness created by the prover in the interactive
    /// protocol. Given a multi_point_evaluation_challenge for 2 sets of
    /// polynomials, return their evaluations (at z_1 for the first set, at z_2
    /// for the second set), and a witness proving the correctness of these
    /// evaluations to a verifier holding the commitments for the polynomials
    /// in the 2 sets..
    class multi_point_evaluation_witness
    {
    public:
        // Evaluation of polynomials f_1s at z_1.
        const std::vector<Field> s_1s;
        // Evaluation of polynomials f_2s at z_2.
        const std::vector<Field> s_2s;
        // Part of witness corresponding to evaluations of f_1s.
        const libff::G1<ppT> W_1;
        // Part of witness corresponding to evaluations of f_2s.
        const libff::G1<ppT> W_2;

        multi_point_evaluation_witness(
            const std::vector<Field> &&s_1s,
            const std::vector<Field> &&s_2s,
            const libff::G1<ppT> &W_1,
            const libff::G1<ppT> &W_2);
    };

    /// Evaluate the polynomials fs and gs at the points z_1 and z_2
    /// respectively, and generate a witness to prove the correctness of these
    /// evaluations. Returns a `multi_point_evaluation_witness` object holding
    /// this data.
    static multi_point_evaluation_witness create_witness(
        const srs &srs,
        const multi_point_evaluation_challenge &challenge,
        const std::vector<polynomial<Field>> &fs,
        const std::vector<polynomial<Field>> &gs);

    /// Given a `multi_point_evaluation_witness` generated for polynomials with
    /// commitments `cm_1s` and `cm_2s`, in response to `challenge`, verify the
    /// witnesses, and thereby that the given polynomials attain the claimed
    /// values at the evaluation points.
    static bool verify_eval(
        const srs &srs,
        const multi_point_evaluation_challenge &challenge,
        const std::vector<commitment> &cm_1s,
        const std::vector<commitment> &cm_2s,
        const multi_point_evaluation_witness &witness,
        const libff::Fr<ppT> &r);
};

} // namespace libsnark

#include "libsnark/polynomial_commitments/kzg10_batched.tcc"

#endif // __LIBSNARK_POLYNOMIAL_COMMITMENTS_KZG10_BATCHED_HPP__
